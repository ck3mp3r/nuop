#!/usr/bin/nu --stdin

# Finalizer identifier
const FINALIZER = "github.com/ck3mp3r/nuop/sec-clnr/finalizer"

# Returns operator config
def 'main config' [] {
  {
    name: "secret-cloner"
    kind: "Secret"
    labelSelectors: {
      "app.kubernetes.io/replicate": "yes"
    }
    finalizer: $FINALIZER
    requeue_after_noop: 60
    version: "v1"
  } | to yaml
}

# Extracts only the relevant fields of a Secret for comparison
def simplify-secret [secret] {
  let labels = ($secret.metadata.labels | default {})
  let simplified_labels = if ($labels | columns | any {|c| $c == 'app.kubernetes.io/replicated-by' }) {
    {"app.kubernetes.io/replicated-by": "github.com/ck3mp3r/nuop/sec-clnr"}
  } else {
    {}
  }

  {
    type: $secret.type
    data: $secret.data
    labels: $simplified_labels
  }
}

# Builds the replicated secret template
def build-template [original] {
  {
    apiVersion: $original.apiVersion
    kind: $original.kind
    metadata: {
      name: $original.metadata.name
      labels: {
        "app.kubernetes.io/managed-by": "github.com/ck3mp3r/nuop/sec-clnr"
        "app.kubernetes.io/replicated-by": "github.com/ck3mp3r/nuop/sec-clnr"
      }
    }
    type: $original.type
    data: $original.data
  }
}

# Deletes all replicated secrets in other namespaces
def delete-replicated-secrets [secret_name, source_namespace] {
  let namespaces = (
    kubectl get namespaces -o json | from json
  ).items
  | get metadata.name
  | where {|ns| $ns != $source_namespace }

  for namespace in $namespaces {
    let result = (kubectl get secret $secret_name -n $namespace -o yaml | complete)
    if $result.exit_code == 0 {
      print $"‚ùå Deleting replicated secret in ($namespace)"
      kubectl delete secret $secret_name -n $namespace | complete | ignore
    }
  }
}

# Reconciliation logic for create/update events
def handle-reconcile [parsed] {
  mut changed = false

  let source_namespace = $parsed.metadata.namespace
  let secret_name = $parsed.metadata.name

  let original_result = (kubectl get secret $secret_name -n $source_namespace -o yaml | complete)
  if $original_result.exit_code != 0 {
    print $"‚ö†Ô∏è Source secret ($secret_name) in ($source_namespace) not found ‚Äî skipping reconcile"
    exit 0
  }

  let original = $original_result.stdout | from yaml

  let template = build-template $original
  let source_simplified = simplify-secret $template

  let namespaces = (
    kubectl get namespaces -o json | from json
  ).items
  | get metadata.name
  | where {|ns| $ns != $source_namespace }

  for namespace in $namespaces {
    print $"üîç Checking namespace: ($namespace)"

    let result = (kubectl get secret $secret_name -n $namespace -o yaml | complete)
    let existing_secret = if $result.exit_code == 0 {
      $result.stdout | from yaml
    } else {
      null
    }

    let existing_simplified = if $existing_secret != null {
      simplify-secret $existing_secret
    } else {
      null
    }

    if $existing_simplified == null {
      print $"‚ûï Creating secret in ($namespace)"
      ($template | to yaml) | kubectl apply -n $namespace -f -
      $changed = true
    } else if $existing_simplified != $source_simplified {
      print $"üîÑ Updating secret in ($namespace)"
      ($template | to yaml) | kubectl apply -n $namespace -f -
      $changed = true
    } else {
      print $"‚úÖ Secret in ($namespace) is up to date"
    }
  }

  if $changed {
    exit 2
  } else {
    exit 0
  }
}

# Handles deletion of the source secret by cleaning up replicas and removing the finalizer
def handle-deleted [parsed] {
  let source_namespace = $parsed.metadata.namespace
  let secret_name = $parsed.metadata.name

  print "üóë Detected source secret deletion. Cleaning up replicas..."
  delete-replicated-secrets $secret_name $source_namespace

  exit 0
}

# Main dispatch logic
def 'main reconcile' [] {
  let parsed = $in | from yaml
  handle-reconcile $parsed
}

def 'main finalize' [] {
  let parsed = $in | from yaml
  handle-deleted $parsed
}

def main [] {
  help main
}
